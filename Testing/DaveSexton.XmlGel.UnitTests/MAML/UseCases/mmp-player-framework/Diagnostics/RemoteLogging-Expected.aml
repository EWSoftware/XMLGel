<?xml version="1.0" encoding="utf-8"?>
<topic id="9b8da6b9-e710-4211-94aa-7eb5888f57f3" revisionNumber="1">
  <developerConceptualDocument xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
    <introduction>
      <para>One of the greatest benefits of logging is to be able to
report back to a remote server. Fortunately, the Silverlight Media Framework
makes it very easy to support this.</para>
    </introduction>
    <section>
      <title>Logging</title>
      <content>
        <para>In the Microsoft.SilverlightMediaFramework.Logging assembly
are a number of helper and base classes that make it easy to build an
efficient, custom logging client. Take a look at the RemoteDiagnostics sample
application for an example of this.</para>
        <para>Here's a rundown on the key pieces of that sample.</para>
      </content>
    </section>
    <section>
      <title>Step 1: Getting started with remote logging</title>
      <content>
        <para>First, you will need to add the following references to your project: </para>
        <list class="bullet">
          <listItem>
            <para>Microsoft.SilverlightMediaFramework.Diagnostics</para>
          </listItem>
          <listItem>
            <para>Microsoft.SilverlightMediaFramework.Monitoring</para>
          </listItem>
          <listItem>
            <para>Microsoft.SilverlightMediaFramework.Logging</para>
          </listItem>
          <listItem>
            <para>System.ComponentModel.Composition</para>
          </listItem>
        </list>
        <para>Next, you will need to create a custom log agent that
inherits from Microsoft.SilverlightMediaFramework.Monitoring.RemoteVideoLogAgent.
A log agent is responsible for receiving all the log objects generated by the
Silverlight Media Framework's Logging component and the RemoteVideoLogAgent base
class will give you automatic support for queuing and batching these logs
before sending them to the server. You will also need to export this class in
order for the Silverlight Media Framework to find it via MEF.</para>
        <code language="none" title=" ">[Export(typeof(ILogAgent))]
public&#xA0;class&#xA0;RemoteLogAgent&#xA0;:&#xA0;RemoteVideoLogAgent
{
}</code>
        <para />
        <para />
        <para />
      </content>
    </section>
    <section>
      <title>Step 2: Configuration</title>
      <!--h3-->
      <content>
        <para>In order for the base class to know how to batch and queue,
it needs some configuration settings. These settings are defined in the BatchingConfig
object and must be passed to the constructor of the base class. To support
this, we will load the configuration from an xml file using a helper method on
BatchingConfig and overload the constructor to pass it to RemoteVideoLogAgent.</para>
        <code language="none" title=" ">[Export(typeof(ILogAgent))]
public&#xA0;class&#xA0;RemoteLogAgent&#xA0;:&#xA0;RemoteVideoLogAgent
{
&#xA0;&#xA0;&#xA0;&#xA0;public&#xA0;RemoteLogAgent()&#xA0;:&#xA0;base(GetConfig())&#xA0;{&#xA0;}
&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;static&#xA0;BatchingConfig&#xA0;GetConfig()
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;BatchingConfig.Load(new&#xA0;Uri("MyConfig.xml",&#xA0;UriKind.Relative));
&#xA0;&#xA0;&#xA0;&#xA0;}
}</code>
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para>&#xA0;(See below for more information about the BatchingConfig
Xml.)</para>
      </content>
    </section>
    <section>
      <title>Step 3: Handling the batches of logs</title>
      <content>
        <para>Last but not least we need to actually handle the batches of
logs and send them to our server. To do this we need to create a class that
implements IBatchAgent and pass an instance of it to the config object.</para>
        <code language="none" title=" ">[Export(typeof(ILogAgent))]
public&#xA0;class&#xA0;RemoteLogAgent&#xA0;:&#xA0;RemoteVideoLogAgent
{
&#xA0;&#xA0;&#xA0;&#xA0;public&#xA0;RemoteLogAgent()&#xA0;:&#xA0;base(GetConfig())&#xA0;{&#xA0;}
&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;static&#xA0;BatchingConfig&#xA0;GetConfig()
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var&#xA0;result&#xA0;=&#xA0;BatchingConfig.Load(new&#xA0;Uri("MyConfig.xml",&#xA0;UriKind.Relative));
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;result.BatchAgent&#xA0;=&#xA0;new&#xA0;MyBatchAgent();
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return&#xA0;result;
&#xA0;&#xA0;&#xA0;&#xA0;}
}</code>
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para>IBatchAgent is very simple and only has one method:
LogBatchAsync and one event: LogBatchCompleted. Here is an example
implementation of this interface that serializes the batch to Xml and passes it
up to the server as a string.</para>
        <code language="none" title=" ">public&#xA0;class&#xA0;MyBatchAgent&#xA0;:&#xA0;IBatchAgent
{
&#xA0;&#xA0;&#xA0;&#xA0;Service1Client&#xA0;svc; 
&#xA0;&#xA0;&#xA0;&#xA0;public&#xA0;event&#xA0;EventHandler&lt;LogBatchCompletedEventArgs&gt;&#xA0;LogBatchCompleted;
&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;public&#xA0;MyBatchAgent()
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;svc&#xA0;=&#xA0;new&#xA0;Service1Client();
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;svc.SendBatchCompleted&#xA0;+=&#xA0;svc_SendBatchCompleted;
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;public&#xA0;bool&#xA0;LogBatchAsync(Batch&#xA0;batch)
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;using&#xA0;(Stream&#xA0;stream&#xA0;=&#xA0;new&#xA0;MemoryStream())
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;batch.Serialize(XmlWriter.Create(stream));
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;stream.Position&#xA0;=&#xA0;0;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;svc.SendBatchAsync(new&#xA0;StreamReader(stream).ReadToEnd(),&#xA0;batch);
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return&#xA0;true;
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;void&#xA0;svc_SendBatchCompleted(object&#xA0;sender,&#xA0;SendBatchCompletedEventArgs&#xA0;e)
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;if&#xA0;(LogBatchCompleted&#xA0;!=&#xA0;null)
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Batch&#xA0;batch&#xA0;=&#xA0;e.UserState&#xA0;as&#xA0;Batch;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;if&#xA0;(e.Error&#xA0;==&#xA0;null)
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;success!
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;LogBatchCompleted(this,
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;new&#xA0;LogBatchCompletedEventArgs(null&#xA0;as&#xA0;LogBatchResult,&#xA0;batch));
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;else
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;error
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;LogBatchCompleted(this,
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;new&#xA0;LogBatchCompletedEventArgs(e.Error,&#xA0;batch));
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;}
}</code>
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
        <para />
      </content>
    </section>
    <section>
      <title>Step 4: LogBatchResult (optional)</title>
      <!--h3-->
      <content>
        <para>One thing you may notice above is that we are raising the LogBatchCompleted event and passing null:</para>
        <code language="none" title=" " />
        <para>LogBatchCompleted(this, new&#xA0;LogBatchCompletedEventArgs(null&#xA0;as&#xA0;LogBatchResult,&#xA0;batch));</para>
        <para>The LogBatchResult object that is passed back in the
LogBatchCompleted event has properties to alter the behavior of the
LogBatchAgent. With it you can change the polling interval, disable logging
entirely, or calibrate the local time stamp attached to each log by offsetting
it with the difference between itself and the server's time (thereby making log
timestamps closely synced with the server time). Please refer to the
LogBatchResult API for more information. Passing null indicates that everything should keep running as usual.</para>
      </content>
    </section>
    <section>
      <title>Further possible performance improvements</title>
      <content>
        <list class="bullet">
          <listItem>
            <para>Zip the serialized stream to use the least amount of bandwidth
as possible.</para>
          </listItem>
          <listItem>
            <para>Create mapping configuration settings to shrink the dictionary
keys and drop unwanted data from your logs. Please refer to the API reference
for Microsoft.SilverlightMediaFramework.Logging.Mapping.MappingRules for more
information.</para>
          </listItem>
        </list>
      </content>
    </section>
    <relatedTopics />
  </developerConceptualDocument>
</topic>